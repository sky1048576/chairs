{"version":3,"sources":["utils/index.js","components/Seatmap/index.js","components/Seatmap/Seatmap.jsx","App.jsx","serviceWorker.js","index.js"],"names":["calculateMaxY","data","maxY","forEach","block","endPoint","y","sortResponse","response","sortedResponse","blocks","blockObj","block_id","seats","seat","seatObj","schedule_seat_id","seat_id","x","type","row","number","price","push","startPoint","reduce","prev","current","array","findMaxPoint","block1","block2","xOverlap","yOverlap","doBlocksOverlap","yTrans","moveBlockToEndY","sortOverlapedBlocks","Seatmap","selected","width","height","onSeatClick","onBlockClick","disablePinch","disablePan","useState","boundingBox","setBoundingBox","fixRatio","box","prevStartPoint","prevEndPoint","currentStartPoint","currentEndPoint","getBoundingBox","isSeatSelected","findIndex","_","useEffect","offset","SEAT_BORDER","SEAT_WIDTH","viewBox","doubleClick","mode","disabled","pan","pinch","zoomIn","zoomOut","wheel","preserveAspectRatio","map","index","key","onClick","event","BLOCK_LEFT_RIGHT_PADDING","BLOCK_TOP_BOTTOM_PADDING","fill","rx","ry","stroke","strokeWidth","prevSelected","App","open","item","selectModal","setSelectModal","seatmaps","setSeatmaps","setSelected","handleCloseSelectModal","clear","seatmapData","className","Fragment","selectedIndex","select","newSelected","concat","slice","length","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.e0b4f373.chunk.js","sourcesContent":["// finds max x, y in an array\nconst findMaxPoint = array => {\n    return array.reduce((prev, current) => {\n        const x = prev.x > current.x ? prev.x : current.x;\n        const y = prev.y > current.y ? prev.y : current.y;\n\n        return { x, y };\n    });\n};\n\n\n// finds min x, y in an array\nconst findMinPoint = array => {\n    return array.reduce((prev, current) => {\n        const x = prev.x < current.x ? prev.x : current.x;\n        const y = prev.y < current.y ? prev.y : current.y;\n\n        return { x, y };\n    });\n};\n\n// ===============================================\n//         Check overlap functions\n// ==============================================\n/************\n * Check x point\n */\n\n// if we have overlaps in xAxis\nconst xOverlap = (block1, block2) => {\n    return block1.startPoint.x >= block2.startPoint.x &&\n        block1.startPoint.x <= block2.endPoint.x ?\n        true :\n        false;\n};\n\n// if we have overlaps in yAxis\nconst yOverlap = (block1, block2) => {\n    return block1.startPoint.y >= block2.startPoint.y &&\n        block1.startPoint.y <= block2.endPoint.y ?\n        true :\n        false;\n};\n\n// if we have overlaps in area\nconst doBlocksOverlap = (block1, block2) => {\n    return xOverlap(block1, block2) && yOverlap(block1, block2) ? true : false;\n};\n\n\n// finds max Y of the blocks\nconst calculateMaxY = data => {\n    let maxY = 0;\n    data.forEach(block => {\n        maxY = maxY > block.endPoint.y ? maxY : block.endPoint.y;\n    });\n    return maxY;\n};\n\n// moves overlaped blocks to the max Y\nconst moveBlockToEndY = (block, y) => {\n    const yTrans = y - block.startPoint.y + 120;\n\n    block.startPoint.y = yTrans;\n    block.endPoint.y += yTrans;\n\n    block.seats.forEach(seat => {\n        seat.y += yTrans;\n    });\n};\n// set the values to the response\nconst sortOverlapedBlocks = data => {\n    let maxY = calculateMaxY(data);\n\n    // check block to block to see if we have overlaps\n    data.forEach(block1 =>\n        data.forEach(block2 => {\n\n            if (block1.block_id !== block2.block_id) {\n                if (doBlocksOverlap(block1, block2)) {\n                    maxY = calculateMaxY(data);\n                    moveBlockToEndY(block2, maxY);\n                }\n            }\n        })\n    );\n};\n// ==========================================\n//          End overlap functions\n// ==========================================\n\n// api response is a little bit weird so filter it to a better format here\n\nconst sortResponse = response => {\n    const sortedResponse = [];\n\n    response.blocks.forEach(block => {\n        let blockObj = { block_id: block.block_id };\n        blockObj.seats = [];\n\n        // convert array type data to a object form data\n        block.seats.forEach(seat => {\n            let seatObj = {\n                schedule_seat_id: seat[0],\n                seat_id: seat[1],\n                x: seat[2],\n                y: seat[3],\n                type: seat[4],\n                row: seat[5],\n                number: seat[6],\n                price: seat[7]\n            };\n            blockObj.seats.push(seatObj);\n\n            const startPoint = findMinPoint(blockObj.seats);\n            const endPoint = findMaxPoint(blockObj.seats);\n\n            blockObj.startPoint = startPoint;\n            blockObj.endPoint = endPoint;\n        });\n\n        sortedResponse.push(blockObj);\n    });\n\n    // fixes overlaped blocks coordinates\n    sortOverlapedBlocks(sortedResponse);\n\n    return sortedResponse;\n};\n\nexport { sortResponse, findMaxPoint, findMinPoint };","import Seatmap from \"./Seatmap\";\n\nexport default Seatmap;\n","import React, { useState, useEffect } from \"react\";\n\n// components\nimport { TransformWrapper, TransformComponent } from \"react-zoom-pan-pinch\";\n\n// length\nconst SEAT_WIDTH = 28;\nconst SEAT_RADIOUS = 4;\nconst SEAT_BORDER = 0.3;\n\nconst SEATS_HORIZENTAL_SPACE = 6;\nconst SEATS_VERTICAL_SPACE = 7;\n\nconst BLOCK_TOP_BOTTOM_PADDING = 12;\nconst BLOCK_LEFT_RIGHT_PADDING = 12;\n\nconst BLOCKS_SPACE = 12;\nconst BLOCK_RADIUS = 6;\n\n// color\nconst RESERVED_SEAT_COLOR = \"#e2e2e2\";\nconst SELECTED_SEAT_COLOR = \"#009777\";\nconst SELECTABLE_SEAT_BORDER_COLOR = \"#808285\";\nconst BLOCK_BACKGROUND_COLOR = \"#f7f7f7\";\n\nconst Seatmap = ({\n  data,\n  selected,\n  width,\n  height,\n  onSeatClick,\n  onBlockClick,\n  disablePinch,\n  disablePan\n}) => {\n  const [boundingBox, setBoundingBox] = useState({});\n\n  // get bounding box properties, what is bounding box? it's the imaginary box that covers all the blocks we drew\n  const getBoundingBox = () => {\n    // it should return startPoint, endPoint and offeset left and right of bounding-box\n    const box = data.reduce((prev, current) => {\n      // prev\n      const prevStartPoint = prev.startPoint;\n      const prevEndPoint = prev.endPoint;\n\n      // current\n      const currentStartPoint = current.startPoint;\n      const currentEndPoint = current.endPoint;\n\n      // find max startPoint of the bounding box\n      const boxStartX =\n        prevStartPoint.x < currentStartPoint.x\n          ? prevStartPoint.x\n          : currentStartPoint.x;\n      const boxStartY =\n        prevStartPoint.y < currentStartPoint.y\n          ? prevStartPoint.y\n          : currentStartPoint.y;\n\n      // find min startPoint of the bounding box\n      const boxEndX =\n        prevEndPoint.x > currentEndPoint.x ? prevEndPoint.x : currentEndPoint.x;\n      const boxEndY =\n        prevEndPoint.y > currentEndPoint.y ? prevEndPoint.y : currentEndPoint.y;\n\n      return {\n        startPoint: { x: boxStartX, y: boxStartY },\n        endPoint: { x: boxEndX, y: boxEndY }\n      };\n    });\n\n    // mesure width and height of the bounding box\n    const width = box.endPoint.x - box.startPoint.x;\n    const height = box.endPoint.y - box.startPoint.y;\n\n    return {\n      ...box,\n      width,\n      height\n    };\n  };\n\n  // mesures bounding box, bounding box is used to fit drawing in the view-box of the svg\n  const fixRatio = () => {\n    const boundingBox = getBoundingBox();\n    setBoundingBox(boundingBox);\n  };\n\n  // checks if seat_id exists in the selected list\n  const isSeatSelected = seat =>\n    selected && selected.findIndex(_ => _.seat_id === seat.seat_id) > -1;\n\n  // on component did mount\n  useEffect(() => {\n    fixRatio();\n  }, []);\n\n  /** block startPoint and endPoint did came from thier seats startPoints\n  so we  need to add SEAT_WIDTH to it to fit all the seats in also we have some padding\n  here so we substract them from block startPoint and add it to the endPoint to get the padding */\n  const offset = {\n    startPoint: {\n      x: SEAT_BORDER + BLOCK_LEFT_RIGHT_PADDING,\n      y: SEAT_BORDER + BLOCK_TOP_BOTTOM_PADDING\n    },\n    endPoint: {\n      x:\n        SEAT_WIDTH +\n        SEAT_BORDER +\n        SEAT_BORDER +\n        BLOCK_LEFT_RIGHT_PADDING +\n        BLOCK_LEFT_RIGHT_PADDING,\n      y:\n        SEAT_WIDTH +\n        SEAT_BORDER +\n        SEAT_BORDER +\n        BLOCK_TOP_BOTTOM_PADDING +\n        BLOCK_TOP_BOTTOM_PADDING\n    }\n  };\n\n  /** we use the offset above and bounging box properties to draw the imaginary\n  viewBox this will help us to cover drawing in the screen */\n\n  const viewBox =\n    boundingBox.startPoint &&\n    boundingBox.endPoint &&\n    `${boundingBox.startPoint.x - offset.startPoint.x} ${boundingBox.startPoint\n      .y - offset.startPoint.y} ${boundingBox.width +\n      offset.endPoint.x} ${boundingBox.height + offset.endPoint.y}`;\n\n  return (\n    <TransformWrapper\n      doubleClick={{ mode: \"reset\", disabled: true }}\n      pan={{ disabled: disablePan }}\n      pinch={{ disabled: disablePinch }}\n      zoomIn={{ disabled: disablePinch }}\n      zoomOut={{ disabled: disablePinch }}\n      wheel={{ disabled: disablePinch }}\n    >\n      <TransformComponent>\n        <svg\n          width={width}\n          height={height}\n          viewBox={viewBox}\n          preserveAspectRatio=\"xMidYMid\"\n        >\n          <g>\n            {data.map((block, index) => {\n              return (\n                <g\n                  key={index}\n                  onClick={event => onBlockClick && onBlockClick(event, block)}\n                >\n                  <rect\n                    x={block.startPoint.x - BLOCK_LEFT_RIGHT_PADDING}\n                    y={block.startPoint.y - BLOCK_TOP_BOTTOM_PADDING}\n                    width={\n                      block.endPoint.x -\n                      block.startPoint.x +\n                      SEAT_WIDTH +\n                      BLOCK_LEFT_RIGHT_PADDING * 2\n                    }\n                    height={\n                      block.endPoint.y -\n                      block.startPoint.y +\n                      SEAT_WIDTH +\n                      BLOCK_TOP_BOTTOM_PADDING * 2\n                    }\n                    fill={BLOCK_BACKGROUND_COLOR}\n                    rx={BLOCK_RADIUS}\n                    ry={BLOCK_RADIUS}\n                  />\n\n                  {block.seats.map((seat, index) => (\n                    <rect\n                      key={index}\n                      onClick={event => onSeatClick && onSeatClick(event, seat)}\n                      x={seat.x}\n                      y={seat.y}\n                      width={SEAT_WIDTH}\n                      height={SEAT_WIDTH}\n                      rx={SEAT_RADIOUS}\n                      ry={SEAT_RADIOUS}\n                      fill={\n                        isSeatSelected(seat)\n                          ? SELECTED_SEAT_COLOR\n                          : \"transparent\"\n                      }\n                      stroke={SELECTABLE_SEAT_BORDER_COLOR}\n                      strokeWidth={SEAT_BORDER}\n                    />\n                  ))}\n                </g>\n              );\n            })}\n          </g>\n        </svg>\n      </TransformComponent>\n    </TransformWrapper>\n  );\n};\n\nexport default Seatmap;\n","import React, { useState, useEffect } from \"react\";\n\n// utils\nimport { sortResponse } from \"./utils\";\n\n// data\nimport response from \"./response2.json\";\n\n// components\nimport Seatmap from \"./components/Seatmap\";\n\n// styles\nimport \"./App.css\";\n\n// stores prev selected seats, after cancel we set selected to this variable\nlet prevSelected = [];\n\nconst App = () => {\n  const [selectModal, setSelectModal] = useState({ open: false, item: [] });\n  const [seatmaps, setSeatmaps] = useState(null);\n  const [selected, setSelected] = useState([]);\n\n  // open select modal, item is the selected block object\n  const handleOpenSelectModal = (event, item) => {\n    setSelectModal({ open: true, item: [item] });\n    prevSelected = selected;\n  };\n\n  // close select modal, has a clear parameter if true: clear selected list else keep the state\n  const handleCloseSelectModal = (event, clear) => {\n    setSelectModal({ open: false });\n    clear && setSelected(prevSelected);\n  };\n\n  // on seat click\n  const handleSeatClick = (event, seat) => {\n    const selectedIndex = selected.findIndex(\n      select => select.seat_id === seat.seat_id\n    );\n\n    let newSelected = [];\n\n    // if we didn't find the index add it to the array\n    if (selectedIndex === -1) {\n      newSelected = newSelected.concat(selected, seat);\n    }\n    // if is the first index remove it\n    else if (selectedIndex === 0) {\n      newSelected = newSelected.concat(selected.slice(1));\n    }\n    // if is the last index remove it\n    else if (selectedIndex === selected.length - 1) {\n      newSelected = newSelected.concat(selected.slice(0, -1));\n    }\n    // if is in middle remove it\n    else if (selectedIndex > 0) {\n      newSelected = newSelected.concat(\n        selected.slice(0, selectedIndex),\n        selected.slice(selectedIndex + 1)\n      );\n    }\n    setSelected(newSelected);\n  };\n\n  // on component did mount\n  useEffect(() => {\n    // sort response from api to the better data structure\n    const seatmapData = sortResponse(response.data);\n    setSeatmaps(seatmapData);\n  }, []);\n\n  return (\n    <div className=\"app\">\n      {!selectModal.open && (\n        <div className=\"modal\">\n          <div className=\"modal_header\">\n            <h3>Cinema</h3>\n          </div>\n\n          <div className=\"modal_content\">\n            {seatmaps && (\n              <Seatmap\n                disablePan\n                disablePinch\n                width=\"100%\"\n                selected={selected}\n                height={250}\n                data={seatmaps}\n                onBlockClick={handleOpenSelectModal}\n              />\n            )}\n          </div>\n        </div>\n      )}\n\n      {selectModal.open && (\n        <React.Fragment>\n          <div className=\"backdrop\"></div>\n          <div className=\"dialog\">\n            <button\n              className=\"exit-button\"\n              onClick={event => handleCloseSelectModal(event, true)}\n            >\n              X\n            </button>\n            <div className=\"modal_header\">\n              <h3>Select</h3>\n            </div>\n\n            <div className=\"modal_content\">\n              <Seatmap\n                width=\"100%\"\n                height={250}\n                data={selectModal.item}\n                onSeatClick={handleSeatClick}\n                selected={selected}\n              />\n            </div>\n\n            <div className=\"modal_actions\">\n              <button\n                onClick={event => handleCloseSelectModal(event, false)}\n                className=\"button\"\n              >\n                Reserve\n              </button>\n            </div>\n          </div>\n        </React.Fragment>\n      )}\n    </div>\n  );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}